name: Generate Flutter App (Improved)

on:
  workflow_dispatch:
    inputs:
      jobId:
        description: "Job ID for tracking"
        required: true
      storeId:
        description: "Store ID"
        required: true
      callbackUrl:
        description: "Callback URL for status updates"
        required: true
      config:
        description: "Store configuration JSON"
        required: true

jobs:
  generate:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3

      - name: Set up Node.js
        uses: actions/setup-node@v3
        with:
          node-version: "16"
          cache: "npm"

      - name: Install dependencies
        run: npm ci

      - name: Validate callback URL
        run: |
          CALLBACK_URL="${{ github.event.inputs.callbackUrl }}"
          if [[ "$CALLBACK_URL" == *"localhost"* || "$CALLBACK_URL" == *"undefined"* || -z "$CALLBACK_URL" ]]; then
            echo "Error: Invalid callback URL: $CALLBACK_URL. Cannot use localhost in production."
            exit 1
          fi
          echo "Callback URL validated: $CALLBACK_URL"

      - name: Create config file
        run: |
          echo '${{ github.event.inputs.config }}' > quick-config.json
          npm run convert:to-store

      - name: Scan Template files
        id: scan
        run: |
          npm run scan:fashion
      - name: Generate Flutter app
        id: generate
        run: |
          npm run generate:fashion
          echo "Listing generated directory contents:"
          ls -la generated-app

      # Clear Flutter SDK caches and install the required version
      - name: Clean any existing Flutter installations
        run: |
          rm -rf $HOME/.flutter $HOME/.pub-cache
          
      # Use a Flutter version with Dart SDK 3.7.0 or newer
      - name: Setup Flutter
        uses: subosito/flutter-action@v2
        with:
          channel: 'stable'
          cache: false  # Disable caching to ensure clean installation

      - name: Verify Flutter and Dart versions
        run: |
          flutter --version
          dart --version
          
      # Update the dependency constraints in pubspec.yaml with improved regex patterns
      - name: Adjust dependencies in pubspec.yaml
        run: |
          cd generated-app
          echo "Original pubspec.yaml:"
          cat pubspec.yaml
          
          # First, update the SDK constraints to be more permissive with a pattern that matches non-quoted versions
          sed -i 's/sdk: \^3\.7\.0/sdk: ">=2.19.0 <4.0.0"/' pubspec.yaml
          
          # Check for blue_market dependency and adjust if present
          if grep -q "blue_market:" pubspec.yaml; then
            echo "Found blue_market dependency, adjusting version constraints..."
            # Remove specific version constraints or replace with compatible version
            sed -i 's/blue_market:.*$/blue_market: any/' pubspec.yaml
          fi
          
          # Then update flutter_lints to a compatible version
          if grep -q "flutter_lints:" pubspec.yaml; then
            sed -i 's/flutter_lints: \^5\.0\.0/flutter_lints: ^2.0.0/' pubspec.yaml
          fi
          
          echo "Modified pubspec.yaml:"
          cat pubspec.yaml
          
      - name: Installing app dependencies with detailed logging
        id: dependencies
        continue-on-error: true  # Continue even if this step fails
        run: |
          cd generated-app
          echo "Running flutter pub get with detailed output..."
          flutter pub get --verbose > pub_get_log.txt 2>&1
          EXIT_CODE=$?
          
          if [ $EXIT_CODE -ne 0 ]; then
            echo "Flutter pub get failed with exit code $EXIT_CODE"
            echo "Error log:"
            cat pub_get_log.txt
            
            # Try to fix common issues automatically with improved method
            echo "Attempting automatic fixes..."
            
            # More robust replacement for SDK constraints
            sed -i -E 's/(sdk:[ ]*)[^\s]+/\1">=2.12.0 <4.0.0"/' pubspec.yaml
            
            # Remove all version constraints from dependencies with a more robust approach
            sed -i '/dependencies:/,/dev_dependencies:/ s/: \^[0-9.]+/: any/g' pubspec.yaml
            
            echo "Modified pubspec.yaml after auto-fix:"
            cat pubspec.yaml
            
            echo "Retrying flutter pub get..."
            flutter pub get
          else
            echo "Flutter pub get completed successfully"
          fi
          
      - name: Generate app icon
        id: icon
        if: steps.dependencies.outcome == 'success'
        continue-on-error: true
        run: |
          cd generated-app
          flutter pub run flutter_launcher_icons:main
          
      - name: Generate app splash
        id: splash
        if: steps.icon.outcome == 'success'
        continue-on-error: true
        run: |
          cd generated-app
          flutter pub run flutter_native_splash:create

      - name: Build APK
        id: build_apk
        if: steps.splash.outcome == 'success'
        continue-on-error: true
        run: |
          cd generated-app
          flutter build apk --target-platform android-arm64 --analyze-size
      - name: Check APK size
        run: |
          cd generated-app/build/app/outputs/flutter-apk
          ls -lh app-release.apk
      - name: Upload APK to ImageKit
        id: imagekit_upload
        if: steps.build_apk.outcome == 'success'
        continue-on-error: true
        env:
          IMAGEKIT_PUBLIC_KEY: ${{ secrets.IMAGEKIT_PUBLIC_KEY }}
          IMAGEKIT_PRIVATE_KEY: ${{ secrets.IMAGEKIT_PRIVATE_KEY }}
          IMAGEKIT_URL_ENDPOINT: ${{ secrets.IMAGEKIT_URL_ENDPOINT }}
        run: |
          npm install imagekit
          cat <<EOF > upload.js
          const ImageKit = require('imagekit');
          const fs = require('fs').promises;
          const imagekit = new ImageKit({
            publicKey: process.env.IMAGEKIT_PUBLIC_KEY,
            privateKey: process.env.IMAGEKIT_PRIVATE_KEY,
            urlEndpoint: process.env.IMAGEKIT_URL_ENDPOINT
          });
          async function upload() {
            const apkPath = 'generated-app/build/app/outputs/flutter-apk/app-release.apk';
            const file = await fs.readFile(apkPath);
            const result = await imagekit.upload({
              file: file,
              fileName: 'app-${{ github.event.inputs.storeId }}-${{ github.event.inputs.jobId }}.apk',
              folder: '/store-apps'
            });
            console.log(result.url);
          }
          upload().catch(error => {
            console.error(error);
            process.exit(1);
          });
          EOF
          DOWNLOAD_URL=$(node upload.js)
          if [ -n "$DOWNLOAD_URL" ]; then
            echo "download_url=$DOWNLOAD_URL" >> $GITHUB_OUTPUT
            echo "APK uploaded to: $DOWNLOAD_URL"
          else
            echo "Failed to upload APK"
            exit 1
          fi
      - name: Upload APK as GitHub artifact (backup)
        if: steps.build_apk.outcome == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: app-release
          path: generated-app/build/app/outputs/flutter-apk/app-release.apk

      # Enhanced callback with robust error handling, retries and URL validation
      - name: Send completion callback
        if: always()
        run: |
          STATUS="FAILED"
          PROGRESS=0
          MESSAGE="Flutter app generation failed"
          
          # Initialize with empty string, not undefined
          DOWNLOAD_URL=""
          
          # Debug information
          echo "ImageKit upload outcome: ${{ steps.imagekit_upload.outcome }}"
          echo "ImageKit download URL output: ${{ steps.imagekit_upload.outputs.download_url }}"
          
          # If APK was successfully built and uploaded
          if [[ "${{ steps.imagekit_upload.outcome }}" == "success" ]]; then
            if [[ -n "${{ steps.imagekit_upload.outputs.download_url }}" ]]; then
              STATUS="COMPLETED"
              PROGRESS=100
              MESSAGE="Flutter app generation completed successfully"
              DOWNLOAD_URL="${{ steps.imagekit_upload.outputs.download_url }}"
              echo "Download URL set to: $DOWNLOAD_URL"
            else
              echo "Warning: ImageKit upload was successful but no download URL was provided"
            fi
          else
            # Determine failure point for better error message
            if [[ "${{ steps.dependencies.outcome }}" != "success" ]]; then
              MESSAGE="Failed to install Flutter dependencies - Dart SDK version mismatch"
            elif [[ "${{ steps.build_apk.outcome }}" != "success" ]]; then
              MESSAGE="Failed to build APK"
            else
              MESSAGE="Failed to upload APK to storage"
            fi
          fi
          
          # Validate callback URL - don't proceed if it's invalid
          CALLBACK_URL="${{ github.event.inputs.callbackUrl }}"
          
          if [[ "$CALLBACK_URL" == *"localhost"* || "$CALLBACK_URL" == *"undefined"* || -z "$CALLBACK_URL" ]]; then
            echo "Error: Invalid callback URL: $CALLBACK_URL"
            echo "Skipping callback due to invalid URL"
            exit 0
          fi
          
          echo "Callback URL: $CALLBACK_URL"
          
          # Construct the JSON payload using a temporary file to avoid shell interpretation issues
          cat > payload.json << EOF
          {
            "jobId": "${{ github.event.inputs.jobId }}",
            "status": "$STATUS",
            "downloadUrl": "$DOWNLOAD_URL",
            "progress": $PROGRESS,
            "message": "$MESSAGE"
          }
          EOF
          
          # Show the payload for debugging
          echo "Sending payload:"
          cat payload.json
          
          # Send callback with retries
          MAX_RETRIES=3
          RETRY_COUNT=0
          SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$SUCCESS" != "true" ]; do
            echo "Sending callback, attempt $((RETRY_COUNT+1)) of $MAX_RETRIES"
            
            HTTP_STATUS=$(curl -s -o response.txt -w "%{http_code}" -X POST "$CALLBACK_URL" \
              -H "Content-Type: application/json" \
              --data @payload.json)
              
            if [ "$HTTP_STATUS" -ge 200 ] && [ "$HTTP_STATUS" -lt 300 ]; then
              echo "Callback succeeded with HTTP status $HTTP_STATUS"
              SUCCESS=true
              break
            else
              echo "Callback failed with HTTP status $HTTP_STATUS"
              echo "Response body:"
              cat response.txt
              
              RETRY_COUNT=$((RETRY_COUNT+1))
              if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
                WAIT_TIME=$((5 * RETRY_COUNT))
                echo "Waiting $WAIT_TIME seconds before retry..."
                sleep $WAIT_TIME
              fi
            fi
          done
          
          if [ "$SUCCESS" != "true" ]; then
            echo "All callback attempts failed."
          fi